<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Sorm by nikita-volkov</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Sorm</h1>
        <p class="header">A case-classes oriented ORM framework for Scala</p>

        <ul>
          <li class="download"><a class="buttons" href="https://github.com/nikita-volkov/sorm/zipball/master">Download ZIP</a></li>
          <li class="download"><a class="buttons" href="https://github.com/nikita-volkov/sorm/tarball/master">Download TAR</a></li>
          <li><a class="buttons github" href="https://github.com/nikita-volkov/sorm">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/nikita-volkov">nikita-volkov</a></p>


      </header>
      <section>
        <h1>SORM. A complete abstraction ORM framework for Scala</h1>

<p>SORM is an object-relational mapping framework having simplicity of use and absolute abstraction from relational side at its core principles. It automagically creates database tables, emits queries, inserts, updates and deletes records. This all functionality is presented to the user with a simple API which works on standard Scala's case classes. </p>

<p>Using SORM there is absolutely no need for the user to know anything about SQL, DDL and what concepts like many-to-many or one-to-many even mean. One can develop an application knowing that database integration will be a trivial step.</p>

<h2>Project status</h2>

<p>Currently the project is in active development. Release of first stable version 0.1.0 is expected in the comming weeks as of September of 2012. </p>

<p>The framework is already in a perfectly working state and is being heavily use-tested in some private projects, but until the actual release the API is subject to changes and therefore there won't yet be any more documentation than what is in the "Getting started" section.</p>

<h2>Known issues</h2>

<ul>
<li>No rows deletion functionality. Comming soon, definitely before release.</li>
<li>Memory leak. This is due to Scala 2.10-M7 reflection bug, which is expected to be fixed in the next release.</li>
</ul><h2>Supported databases</h2>

<p>Currently SORM releases are getting tested against MySQL and H2 databases. Other DBs may also be supported but are yet not guaranteed to be.</p>

<h2>Future plans</h2>

<ul>
<li>Support for other popular DBs</li>
</ul><h2>Getting started</h2>



<p>Please consider a data model described with these standard case classes:</p>

<pre><code>case class Artist
  ( names : Map[Locale, Seq[String]],
    styles : Set[Style] )

case class Style
  ( names : Map[Locale, Seq[String]] )

case class Locale
  ( code : String )
</code></pre>

<blockquote>
<p>You can see that instead of assigning the <code>Style</code> and <code>Artist</code> objects with a common <code>name</code> property we've decided here to go a bit tougher way to let our application support different locales and to allow it to store different variants of names for the same entity if there exist alternatives. For instance, in the English locale one artist we will store will have three alternative names: "The Rolling Stones", "Rolling Stones" and "Rolling Stones, The".</p>
</blockquote>

<h3>Let's initialize our SORM instance:</h3>

<pre><code>import sorm.Sorm._

val db
  = new Instance(
      entities
        = Set() +
          Entity[Artist]() +
          Entity[Style]() +
          Entity[Locale](),
      url
        = "jdbc:h2:mem:test"
    )
</code></pre>

<blockquote>
<p>If you need an explanation with the code above, we create a SORM instance ready to work with objects of types <code>Artist</code>, <code>Style</code> and <code>Locale</code>. That instance connects to an in-memory H2 database without specifying user or password.</p>
</blockquote>

<p>Guess what, that's it! We now have an up and running database connection with a full schema structure required for storing our objects already created for us. All that's left to do is put it to use. </p>

<h3>Let's populate it with some data:</h3>

<pre><code>//  create locales:
val ru
  = db.save( Locale("ru") )
val en
  = db.save( Locale("en") )

//  create styles:
val rock
  = db.save( Style( Map( en -&gt; Seq("Rock"),
                         ru -&gt; Seq("Рок") ) ) )
val hardRock
  = db.save( Style( Map( en -&gt; Seq("Hard Rock"),
                         ru -&gt; Seq("Тяжёлый рок", "Тяжелый рок") ) ) )
val metal
  = db.save( Style( Map( en -&gt; Seq("Metal"),
                         ru -&gt; Seq("Метал") ) ) )
val grunge
  = db.save( Style( Map( en -&gt; Seq("Grunge"),
                         ru -&gt; Seq("Грандж") ) ) )

//  create artists:
db.save( Artist( Map( en -&gt; Seq("Metallica"),
                      ru -&gt; Seq("Металика", "Металлика") ),
                 Set( metal, rock, hardRock ) ) )
db.save( Artist( Map( en -&gt; Seq("Nirvana"),
                      ru -&gt; Seq("Нирвана") ),
                 Set( rock, hardRock, grunge ) ) )
db.save( Artist( Map( en -&gt; Seq("Kino"),
                      ru -&gt; Seq("Кино") ),
                 Set( rock ) ) )
db.save( Artist( Map( en -&gt; Seq("The Rolling Stones",
                                "Rolling Stones",
                                "Rolling Stones, The"),
                      ru -&gt; Seq("Ролинг Стоунз",
                                "Роллинг Стоунз",
                                "Роллинг Стоунс",
                                "Ролинг Стоунс") ),
                 Set( rock ) ) )
db.save( Artist( Map( en -&gt; Seq("Dire Straits"),
                      ru -&gt; Seq("Даэр Стрэйтс") ),
                 Set( rock ) ) )
db.save( Artist( Map( en -&gt; Seq("Godsmack"),
                      ru -&gt; Seq("Годсмэк") ),
                 Set( metal, hardRock, rock ) ) )
</code></pre>

<h3>Now let's fetch some data from our populated database:</h3>

<pre><code>//  get an artist by id:
db.one[Artist].filterEquals("id", 2).fetch() // will return Nirvana

//  all artists having a style that has `Hard Rock` in a list of its names
db.all[Artist].filterEquals("names.value.item.value", "Hard Rock").fetch()
</code></pre>
      </section>
      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		
  </body>
</html>